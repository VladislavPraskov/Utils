import android.graphics.ColorSpace
import com.eksaria.parlist.R
import com.eksaria.parlist.android.utils.network.ApiResult
import com.eksaria.parlist.android.utils.network.safeApiCall
import com.eksaria.parlist.android.utils.network.safeCacheCall
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.isActive
import kotlin.coroutines.coroutineContext
import kotlin.coroutines.suspendCoroutine


/**При запросе данных, сначала грузим из кэша,
 * отображаем, потом из сети,
 * сохраняем в кэш и снова отображаем*/
abstract class NetworkBoundResource<NetworkObj, CacheObj, ResultAction>(private val isCacheNeeded: Boolean = true) {
    val result = flow {
        //        delay(4000)
        //        Log.i("sdfdsfsdf","111111111111111111111111111111111111111111111111") //todo почему в livedata создаётся очередь. Когда корутина закрывается?

        // ****** STEP 1: VIEW CACHE ******
        //не лезим в базу, если не надо
        emit(mapToResultAction(if (isCacheNeeded) safeCacheCall({ retrieveCache() }) else null))

        // ****** STEP 2: MAKE NETWORK CALL, SAVE RESULT TO CACHE ******
        when (val apiResult = safeApiCall { networkRequest() }) {
            is ApiResult.Success -> {
                if (apiResult.value == null)
                    emit(mapErrorToResultAction(ApiResult.NetworkError(errorRes = R.string.unknown_error)))
                else {
                    // ****** STEP 3: VIEW CACHE and MARK JOB COMPLETED ******
                    safeCacheCall(
                        cacheCall = { saveCache(apiResult.value) },
                        onSuccess = {
                            //не лезим в базу, если не надо
                            emit(mapToResultAction(if (isCacheNeeded) safeCacheCall({ retrieveCache() }) else null))
                        }
                    )
                }
            }
            is ApiResult.NetworkError -> emit(mapErrorToResultAction(apiResult))
        }
    }

    abstract suspend fun networkRequest(): NetworkObj?
    abstract suspend fun retrieveCache(): CacheObj?
    abstract suspend fun saveCache(networkObject: NetworkObj)
    abstract fun mapToResultAction(cache: CacheObj?): ResultAction
    abstract fun mapErrorToResultAction(error: ApiResult.NetworkError?): ResultAction

}
